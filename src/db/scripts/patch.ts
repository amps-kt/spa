// create-test-instance.ts
import { PrismaClient } from "@prisma/client";
import { faker } from "@faker-js/faker";
import { expand, toInstanceId } from "@/lib/utils/general/instance-params";
import { v4 as uuid } from "uuid";
import { testers } from "@/config/testing-whitelist";

faker.seed(321);

const NUM_FAKES = 50;

const group = "socs";
const subGroup = "lvl-4-and-lvl-5-honours";
const oldInstance = "2024-2025";

const newInstance = "testinstance";
const newDisplayName = "Test Instance";

const oldParams = { group, subGroup, instance: oldInstance };
const newParams = { group, subGroup, instance: newInstance };

const db = new PrismaClient();

async function main() {
  // const flagid = await createTestInstance();
  // if (!flagid) throw new Error("flagundeinfed");
  // await setupUsers();
  // await createFakeProjects(flagid);
  const flag = await db.flag.findUniqueOrThrow({
    where: {
      title_allocationGroupId_allocationSubGroupId_allocationInstanceId: {
        ...expand(newParams),
        title: "Level 4",
      },
    },
    select: { id: true },
  });
  await additionalFakeProjects(flag.id);
}

async function createTestInstance() {
  let l4FlagId: undefined | string;

  await db.$transaction(async (tx) => {
    //Copy AllocationInstance
    const instance = await tx.allocationInstance.findFirst({
      where: toInstanceId(oldParams),
    });

    if (!instance) {
      throw new Error(`Instance ${oldInstance} not found`);
    }

    const { id, ...instanceData } = instance; // Omit autogenerated fields
    await tx.allocationInstance.create({
      data: { ...instanceData, id: newInstance, displayName: newDisplayName },
    });

    console.log("Instance created successfully!");
  });

  await db.$transaction(async (tx) => {
    //Copy Flags

    const oldFlags = await tx.flag.findMany({
      where: { ...expand(oldParams) },
      include: { unitsOfAssessment: { include: { assessmentCriteria: true } } },
    });

    for (const { unitsOfAssessment, ...flag } of oldFlags) {
      const { id, allocationInstanceId, ...rest } = flag; // Omit autogenerated fields
      const newFlag = await tx.flag.create({
        data: { ...rest, allocationInstanceId: newInstance },
      });

      if (flag.title === "Level 4") {
        l4FlagId = newFlag.id;
      }

      for (const { assessmentCriteria, id, ...unit } of unitsOfAssessment) {
        await tx.unitOfAssessment.create({
          data: {
            ...unit,
            flagId: newFlag.id,
            assessmentCriteria: {
              createMany: {
                data: assessmentCriteria.map(
                  ({ description, layoutIndex, title, weight }) => ({
                    description,
                    layoutIndex,
                    title,
                    weight,
                  }),
                ),
              },
            },
          },
        });
      }
    }

    console.log("Flags created successfully!");
  });

  await db.$transaction(async (tx) => {
    //Copy Tags
    const oldTags = await tx.tag.findMany({ where: { ...expand(oldParams) } });
    for (const tag of oldTags) {
      const { id, allocationInstanceId, ...rest } = tag; // Omit autogenerated fields
      await tx.tag.create({
        data: { ...rest, allocationInstanceId: newInstance },
      });
    }

    console.log("Tags created successfully!");
  });

  return l4FlagId;
}

async function setupUsers() {
  await Promise.all(
    testers.map(
      async (t) =>
        await db.user.upsert({
          where: { id: t.guid },
          create: { id: t.guid, name: t.name, email: t.email },
          update: {},
        }),
    ),
  );

  await db.userInInstance.createMany({
    data: testers.map((t) => ({
      ...expand(newParams),
      userId: t.guid,
      joined: true,
    })),
  });

  await db.supervisorDetails.createMany({
    data: testers.map((t) => ({
      ...expand(newParams),
      userId: t.guid,
      projectAllocationLowerBound: 0,
      projectAllocationTarget: 1,
      projectAllocationUpperBound: 10,
    })),
  });

  await db.readerDetails.createMany({
    data: testers.map((t) => ({
      ...expand(newParams),
      userId: t.guid,
      projectAllocationLowerBound: 0,
      projectAllocationTarget: 1,
      projectAllocationUpperBound: 10,
    })),
  });
}

async function createFakeProjects(l4FlagId: string) {
  await db.$transaction(async (db) => {
    const fakeStudents = testers.map((t) => {
      const firstName = faker.person.firstName();
      const lastName = faker.person.lastName();
      const guid = `${faker.string.numeric({ length: 7 })}${lastName[0]}`;
      return {
        name: `${firstName} ${lastName}`,
        email: `${guid}@student.gla.ac.uk`,
        id: guid,
      };
    });

    const fakeProjects = testers.map((t) => ({
      ...expand(newParams),
      capacityLowerBound: 1,
      capacityUpperBound: 1,
      supervisorId: t.guid,
      title: faker.git.commitMessage(),
      description: faker.lorem.sentences(2),
      id: uuid(),
    }));

    await db.user.createMany({ data: fakeStudents });
    await db.userInInstance.createMany({
      data: fakeStudents.map((e) => ({
        ...expand(newParams),
        joined: true,
        userId: e.id,
      })),
    });

    await db.studentDetails.createMany({
      data: fakeStudents.map((t) => ({
        ...expand(newParams),
        studentLevel: 4,
        latestSubmissionDateTime: new Date(),
        userId: t.id,
      })),
    });

    await db.flagOnStudent.createMany({
      data: fakeStudents.map((t) => ({
        ...expand(newParams),
        studentId: t.id,
        flagId: l4FlagId,
      })),
    });

    await db.project.createMany({ data: fakeProjects });

    await db.studentProjectAllocation.createMany({
      data: fakeStudents.map((t, i) => ({
        ...expand(newParams),
        studentRanking: 1,
        projectId: fakeProjects[i].id,
        userId: t.id,
      })),
    });

    await db.readerProjectAllocation.createMany({
      data: testers.map((t, i) => ({
        ...expand(newParams),
        projectId: fakeProjects[(i + 1) % fakeProjects.length].id,
        readerId: t.guid,
        studentId: fakeStudents[(i + 1) % fakeProjects.length].id,
      })),
    });
  });
}

async function additionalFakeProjects(l4FlagId: string) {
  await db.$transaction(async (db) => {
    const fakeStudents = testers.map((t) => {
      return Array(NUM_FAKES)
        .fill(0)
        .map(() => {
          const firstName = faker.person.firstName();
          const lastName = faker.person.lastName();
          const guid = `test-${lastName}-${faker.string.alphanumeric(10)}`;
          return {
            name: `${firstName} ${lastName}`,
            email: `${guid}@student.gla.ac.uk`,
            id: guid,
          };
        });
    });

    const fakeProjects = testers.map((t) => {
      return Array(NUM_FAKES)
        .fill(0)
        .map(() => ({
          ...expand(newParams),
          capacityLowerBound: 1,
          capacityUpperBound: 1,
          supervisorId: t.guid,
          title: faker.git.commitMessage(),
          description: faker.lorem.sentences(2),
          id: uuid(),
        }));
    });

    await db.user.createMany({ data: fakeStudents.flat() });
    await db.userInInstance.createMany({
      data: fakeStudents
        .flat()
        .map((e) => ({ ...expand(newParams), joined: true, userId: e.id })),
    });

    await db.studentDetails.createMany({
      data: fakeStudents
        .flat()
        .map((t) => ({
          ...expand(newParams),
          studentLevel: 4,
          latestSubmissionDateTime: new Date(),
          userId: t.id,
        })),
    });

    await db.flagOnStudent.createMany({
      data: fakeStudents
        .flat()
        .map((t) => ({
          ...expand(newParams),
          studentId: t.id,
          flagId: l4FlagId,
        })),
    });

    await db.project.createMany({ data: fakeProjects.flat() });

    await db.studentProjectAllocation.createMany({
      data: fakeStudents
        .flat()
        .map((t, i) => ({
          ...expand(newParams),
          studentRanking: 1,
          projectId: fakeProjects.flat()[i].id,
          userId: t.id,
        })),
    });

    await db.readerProjectAllocation.createMany({
      data: testers
        .map((t, i) => {
          const proj = fakeProjects[(i + 1) % fakeProjects.length];
          const studs = fakeStudents[(i + 1) % fakeProjects.length];
          return proj.map((e, i) => {
            return {
              ...expand(newParams),
              projectId: e.id,
              readerId: t.guid,
              studentId: studs[i].id,
            };
          });
        })
        .flat(),
    });
  });
}

main()
  .catch(async (e: any) => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await db.$disconnect();
  });
